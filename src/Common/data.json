{
  "sortingInstructions": "Select the sorting algorithm you want to visualize from the dropdown menu. \n Use the slider to adjust the array size / the visualization speed.\n Click the \"Visualize\" button to start the sorting algorithm. \n To start a new sorting visualization, click the \"Restart\" button and repeat the process.",
  "pathFindingInstructions": "Drag and drop the start and finish icons to different cells. \n Place obstacles on the grid by clicking on the cells. \n Choose one of the path-finding algorithms from the dropdown menu.\n Use the slider to adjust the speed of the algorithm visualization.\n Click the \"Visualize\" button to start the algorithm.\n To start a new visualization, click the \"Restart\" button and repeat the process.",
  "BS": {
    "desc": "Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, indicating that the list is sorted. This algorithm is named \"Bubble Sort\" because smaller elements \"bubble\" to the top of the list while larger elements \"sink\" to the bottom.",
    "howItWorks": "1. Start at the beginning of the list. \n  2. Compare the first two elements. If the first element is larger than the second, swap them.\n 3. Move to the next pair of elements (from left to right) and repeat step 2.\n 4. Continue this process for each pair of adjacent elements until you reach the end of the list.\n 5. After one pass through the list, the largest unsorted element will have \"bubbled up\" to the end of the list.\n 6. Repeat steps 1-5 for the remaining unsorted portion of the list, excluding the already sorted elements.\n 7. Continue these steps until no more swaps are needed, indicating that the list is sorted.\n",
    "timeComp": "• Best-case time complexity: O(n) (when the list is already sorted)\n • Average-case time complexity: O(n^2)\n • Worst-case time complexity: O(n^2) (when the list is sorted in reverse order)\n"
  },
  "QS": {
    "desc": "Quick Sort is a highly efficient and widely used sorting algorithm that uses a divide-and-conquer approach to sort a list or an array of elements. It works by selecting a \"pivot\" element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively. Quick Sort is known for its speed and is often the preferred choice for sorting large datasets.",
    "howItWorks": "1. Choose a pivot element from the array. The choice of the pivot can affect the algorithm's performance. In our case we choose the last element.\n 2. Partition the array into two sub-arrays: elements less than the pivot and elements greater than the pivot.\n 3. Recursively apply Quick Sort to both sub-arrays, repeating steps 1 and 2.\n 4. Combine the sorted sub-arrays and the pivot to produce the final sorted array.\n",
    "timeComp": "• Best-case time complexity: O(n log n)\n • Average-case time complexity: O(n log n)\n • Worst-case time complexity: O(n^2) when the pivot selection consistently results in unbalanced partitions."
  },
  "MS": {
    "desc": "Merge Sort is a highly efficient and stable sorting algorithm that divides a list or an array into smaller sub-arrays, sorts those sub-arrays, and then combines them to produce a sorted result. It follows the divide-and-conquer approach, making it a reliable choice for sorting large datasets.",
    "howItWorks": "1. Divide: Divide the unsorted list into two equal sub-lists until each sub-list contains only one element or is empty.\n 2. Conquer: Recursively sort each sub-list. This is done by applying the Merge Sort algorithm to each of the sub-lists, further dividing them until they consist of one or zero elements.\n 3. Combine (Merge): Merge the sorted sub-lists back together in a way that maintains the order. Compare elements from both sub-lists and place them in the correct order in a new merged list.\n 4. Repeat the divide, conquer, and combine steps until you have a single sorted list.\n",
    "timeComp": "• Best-case time complexity: O(n log n) \n• Average-case time complexity: O(n log n)\n • Worst-case time complexity: O(n log n)\n"
  },
  "HS": {
    "desc": "Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure to sort elements efficiently. It is known for its reliable time complexity and is often used when a stable sort is not required. Heap Sort works by transforming the input data into a binary heap, which is then repeatedly converted into a sorted array.",
    "howItWorks": "1. Build a Max-Heap: The first step is to build a binary max-heap from the input data. This is done by repeatedly \"heapifying\" the array. Heapifying involves ensuring that the parent node of every subtree has a greater value than its children.\n 2. Swap and Remove: After the max-heap is constructed, the largest element (the root) is at the top of the heap. Swap it with the last element in the heap and decrease the heap size. The swapped element is now in its correct sorted position.\n 3. Re-Heapify: Heapify the remaining elements in the heap, which have been reduced in size by one after the previous step. This ensures that the next largest element moves to the top.\n 4. Repeat: Repeat steps 2 and 3 until the entire array is sorted. The largest elements keep moving to the end of the array, and the sorted portion grows from the end.\n",
    "timeComp": "• Best-case time complexity: O(n log n) \n • Average-case time complexity: O(n log n)\n • Worst-case time complexity: O(n log n)\n"
  },
  "SS": {
    "desc": "Selection Sort is a straightforward and elementary sorting algorithm that works by dividing the input list into two parts: the sorted and the unsorted portions. It repeatedly selects the smallest (or largest) element from the unsorted part and moves it to its correct position in the sorted part. The algorithm continues this process until the entire list is sorted.",
    "howItWorks": "1. Initial State: The entire list is considered unsorted initially.\n 2. Find the Minimum: Search the unsorted part of the list to find the smallest element.\n 3. Swap: Swap the found minimum element with the first element in the unsorted part. This effectively moves the minimum element to the end of the sorted part.\n 4. Expand the Sorted Part: Increase the boundary between the sorted and unsorted parts by one element. The sorted part grows, and the unsorted part shrinks.\n 5. Repeat: Repeat steps 2-4 until the entire list is sorted.\n",
    "timeComp": "• Best-case time complexity: O(n^2) \n • Average-case time complexity: O(n^2)\n • Worst-case time complexity: O(n^2)\n"
  }
}
